name: On Deploy

on:
  workflow_call:
    inputs:
      branch:
        description: 'Git branch or tag to deploy from'
        required: true
        type: string
      env:
        description: 'Select environment to deploy'
        required: true
        type: string
      gb_project_key:
        description: 'GitHub project key as configured in env variables. i.e. stdpi'
        required: true
        type: string
      gb_app_name:
        description: 'GitHub application name as configured in env variables. i.e. onboarding-api' 
        required: true
        type: string
      node-version:
        required: false
        type: string
        description: The NodeJS version to build the app with.
        default: "20"

jobs:
  deploy:
    name: Deploy application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code at tag
        uses: actions/checkout@v3
        with:
          ref: ${{ inputs.branch }}
      
      - name: Setup NodeJS
        uses: actions/setup-node@v3
        with:
          node-version: ${{ inputs.node-version }}

      - name: Install Yarn 1.22.22
        run: |
          npm install -g yarn@1.22.22
          yarn --version

      - name: Clean and install
        run: yarn install --production --frozen-lockfile

      - name: Set environment variables
        run: |
          echo "Deploying tag ${{ inputs.branch }} to ${{ inputs.env }} environment"
          echo "GitHub project key: ${{ inputs.gb_project_key }}"
          echo "GitHub application name: ${{ inputs.gb_app_name }}"
          echo "ECS cluster name: ${{ inputs.gb_project_key }}-${{ inputs.env }}-ecs-cluster"
          echo "ECR Repo: ${{ inputs.gb_project_key}}-${{ inputs.gb_app_name }}"
          echo "ECS Service: ${{ inputs.gb_project_key}}-${{ inputs.env }}-ecs-service-${{ inputs.gb_app_name }}"

          echo "TAG=${{ inputs.branch }}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${{ inputs.env }}" >> $GITHUB_ENV
          echo "GB_PROJECT_KEY=${{ inputs.gb_project_key }}" >> $GITHUB_ENV
          echo "GB_APP_NAME=${{ inputs.gb_app_name }}" >> $GITHUB_ENV
          echo "ECR_REPO=${{ inputs.gb_project_key }}-${{ inputs.gb_app_name }}" >> $GITHUB_ENV
          echo "ECS_CLUSTER_NAME=${{ inputs.gb_project_key }}-${{ inputs.env }}-ecs-cluster" >> $GITHUB_ENV
          echo "ECS_SERVICE_NAME=${{ inputs.gb_project_key}}-${{ inputs.env }}-ecs-service-${{ inputs.gb_app_name }}" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::050752613795:role/STDServiceRoleForGitHub
          aws-region: us-east-1

      - name: Set up Terraform 1.12.2
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2

      - name: Init and verify terraform plan
        run: |
          yarn tf:init --env $ENVIRONMENT
          yarn tf:plan --env $ENVIRONMENT --image-tag $TAG
      
      - name: Apply terraform plan
        run: yarn tf:apply --env $ENVIRONMENT --image-tag $TAG --auto-approve

      - name: Export Terraform outputs
        run: |
          set -euo pipefail
          echo "Running terraform output and exporting variables..."
          yarn tf:output --env "$ENVIRONMENT"
          yarn tf:output --env "$ENVIRONMENT" > outputs.json

          SANITIZED_APP_NAME="${GB_APP_NAME//-/_}"
          ECS_TASK_DEFINITION=$(jq -r ".${SANITIZED_APP_NAME}_task_definition_arn.value" < outputs.json)
          SUBNET_ID=$(jq -r ".vpc_subnet_id.value" < outputs.json)
          ALLOW_HTTP_SECURITY_GROUP_ID=$(jq -r ".allow_http_security_group_id.value" < outputs.json)

          echo "ECS_TASK_DEFINITION_ARN=$ECS_TASK_DEFINITION" >> "$GITHUB_ENV"
          echo "VPC_SUBNET_ID=$SUBNET_ID" >> "$GITHUB_ENV"
          echo "ALLOW_HTTP_SECURITY_GROUP_ID=$ALLOW_HTTP_SECURITY_GROUP_ID" >> "$GITHUB_ENV"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Check if ECS service exists
        id: check-ecs-service
        run: |
          SERVICE_EXISTS=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER_NAME" \
            --services "$ECS_SERVICE_NAME" \
            --query "services[0].status" \
            --output text 2>/dev/null || echo "MISSING")

          echo "SERVICE_EXISTS=$SERVICE_EXISTS"
          echo "service_status=$SERVICE_EXISTS" >> $GITHUB_OUTPUT

      - name: Create the ECS service
        if: steps.check-ecs-service.outputs.service_status != 'ACTIVE'
        run: | 
          echo "ECS service does not exist. Creating service..."
          aws ecs create-service \
            --cluster "$ECS_CLUSTER_NAME" \
            --service-name "$ECS_SERVICE_NAME" \
            --task-definition "$ECS_TASK_DEFINITION_ARN" \
            --desired-count 1 \
            --launch-type "FARGATE" \
            --network-configuration "awsvpcConfiguration={subnets=[$VPC_SUBNET_ID],securityGroups=[$ALLOW_HTTP_SECURITY_GROUP_ID]}" \
            --platform-version "LATEST"